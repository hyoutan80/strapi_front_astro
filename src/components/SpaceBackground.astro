---
// 宇宙背景アニメーションコンポーネント（Digital Voyage）
---

<div id="space-hero-container" class="relative w-full min-h-[400px] overflow-hidden rounded-3xl border border-border/40 bg-black mb-12">
    <canvas id="space-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
    <div class="relative z-10 flex flex-col items-center justify-center h-full py-16 px-4 text-center pointer-events-none">
        <slot />
    </div>
</div>

<script>
    // 3D的な星のクラス
    class Star {
        x: number;
        y: number;
        z: number;
        width: number;
        height: number;
        cx: number;
        cy: number;

        constructor(width: number, height: number) {
            this.width = width;
            this.height = height;
            this.cx = width / 2;
            this.cy = height / 2;
            this.reset(true);
        }

        reset(initial: boolean = false) {
            this.x = (Math.random() - 0.5) * this.width * 2;
            this.y = (Math.random() - 0.5) * this.height * 2;
            // 初期配置はランダムな奥行き、リセット時は奥から
            this.z = initial ? Math.random() * this.width : this.width; 
        }

        update(speed: number) {
            this.z -= speed;
            if (this.z <= 0) {
                this.reset();
            }
        }

        draw(ctx: CanvasRenderingContext2D) {
            // 遠近法投影
            const scale = 300 / this.z; // 焦点距離のようなもの
            const screenX = this.cx + this.x * scale;
            const screenY = this.cy + this.y * scale;

            // 画面外なら描画しない（ただし線の描画のため少し余裕を持たせる）
            if (screenX < 0 || screenX > this.width || screenY < 0 || screenY > this.height) {
                return;
            }

            const size = Math.max(0.5, (1 - this.z / this.width) * 3);
            const opacity = Math.min(1, (1 - this.z / this.width) * 1.5);

            ctx.fillStyle = `rgba(200, 230, 255, ${opacity})`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // デジタルグリッド（大地/船の甲板）
    class DigitalGrid {
        offset: number = 0;
        width: number;
        height: number;
        speed: number;

        constructor(width: number, height: number, speed: number) {
            this.width = width;
            this.height = height;
            this.speed = speed;
        }

        update() {
            this.offset = (this.offset + this.speed) % 100;
        }

        draw(ctx: CanvasRenderingContext2D) {
            const centerY = this.height / 2;
            const centerX = this.width / 2;
            const horizonY = this.height * 0.8; // グリッドの消失点より少し下

            ctx.save();
            // 下半分にクリッピング
            ctx.beginPath();
            ctx.rect(0, centerY + 50, this.width, this.height);
            ctx.clip();

            // グロー効果
            ctx.shadowBlur = 20;
            ctx.shadowColor = "rgba(0, 255, 255, 0.3)";
            ctx.strokeStyle = "rgba(0, 200, 255, 0.15)";
            ctx.lineWidth = 1;

            // 放射線（奥行き線）
            const lines = 12;
            for (let i = 0; i <= lines; i++) {
                // 画面下部におけるX座標
                const x = (this.width / lines) * i;
                // 消失点（画面中央）に向かって線を引く
                ctx.beginPath();
                ctx.moveTo(x + (x - centerX) * 2, this.height); // 手前を広げる
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
            }

            // 横線（迫ってくる線）
            // 遠近感を出すために指数関数的に間隔を空ける
            for (let i = 0; i < 20; i++) {
                const z = 1000 / (i * 50 + (100 - this.offset) + 100); 
                const y = centerY + (200 * z); // 簡易的な投影

                if (y > this.height) continue;
                if (y < centerY) continue;

                const alpha = Math.min(1, (y - centerY) / (this.height - centerY)); // 遠くは薄く

                ctx.strokeStyle = `rgba(0, 200, 255, ${alpha * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(this.width, y);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    }

    function initCanvas() {
        const container = document.getElementById('space-hero-container');
        const canvas = document.getElementById('space-canvas') as HTMLCanvasElement;
        if (!container || !canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        let width = container.clientWidth;
        let height = container.clientHeight;
        canvas.width = width;
        canvas.height = height;

        // 星々 (Ship movement)
        const stars: Star[] = [];
        const starCount = 300;
        for (let i = 0; i < starCount; i++) {
            stars.push(new Star(width, height));
        }

        // グリッド (Web3 Platform)
        const grid = new DigitalGrid(width, height, 2);

        function drawCore() {
             // 中央の「未来」を示すコア
             const centerX = width / 2;
             const centerY = height / 2;
             
             ctx.save();
             // 強いグロー
             ctx.shadowBlur = 60;
             ctx.shadowColor = "rgba(100, 200, 255, 0.8)";
             ctx.fillStyle = "#fff";
             
             ctx.beginPath();
             ctx.arc(centerX, centerY, 2, 0, Math.PI * 2);
             ctx.fill();
             ctx.restore();
        }

        function animate() {
            if (!ctx) return;
            
            // 残像効果（少し透過した黒で塗りつぶす）
            ctx.fillStyle = "rgba(0, 5, 10, 0.4)"; 
            ctx.fillRect(0, 0, width, height);
            
            // 描画モード：加算（光らせる）
            ctx.globalCompositeOperation = 'lighter';

            // グリッドの更新と描画
            grid.update();
            grid.draw(ctx);

            // 星の更新と描画
            const speed = 15; // ワープ速度
            stars.forEach(star => {
                star.update(speed);
                star.draw(ctx);
            });

            // 中央コア
            drawCore();

            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(animate);
        }

        const handleResize = () => {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            stars.forEach(s => { s.width = width; s.height = height; s.cx = width/2; s.cy = height/2; });
            grid.width = width; grid.height = height;
        };

        window.addEventListener('resize', handleResize);
        animate();
    }

    initCanvas();
    document.addEventListener('astro:page-load', initCanvas);
</script>

<style>
    #space-hero-container {
        box-shadow: 0 0 50px -10px rgba(0, 100, 255, 0.2);
        background: radial-gradient(circle at center, #0a0a2a 0%, #000 100%);
    }
</style>
